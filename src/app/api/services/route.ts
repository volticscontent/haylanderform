import { NextResponse } from "next/server";
import pool from "@/lib/db";

async function ensureServicesTable() {
  const client = await pool.connect();
  try {
    const existsRes = await client.query(`
      SELECT EXISTS (
        SELECT 1 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'services'
      ) AS exists
    `);
    const exists = !!existsRes.rows[0]?.exists;

    if (!exists) {
      await client.query(`
        CREATE TABLE services (
          id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name TEXT NOT NULL,
          value NUMERIC(10,2) NOT NULL,
          description TEXT,
          created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL
        )
      `);
      return;
    }

    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS name TEXT`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS value NUMERIC(10,2)`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS description TEXT`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITHOUT TIME ZONE`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITHOUT TIME ZONE`,
    );
    await client.query(
      `ALTER TABLE services ALTER COLUMN created_at SET DEFAULT NOW()`,
    );
    await client.query(
      `ALTER TABLE services ALTER COLUMN updated_at SET DEFAULT NOW()`,
    );

    const idInfoRes = await client.query(`
      SELECT data_type, is_identity, column_default
      FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = 'services' AND column_name = 'id'
    `);
    const dataType: string | undefined = idInfoRes.rows[0]?.data_type;
    const isIdentity: string | undefined = idInfoRes.rows[0]?.is_identity;
    const columnDefault: string | null | undefined =
      idInfoRes.rows[0]?.column_default;

    if (dataType === "uuid") {
      if (!columnDefault) {
        await client.query("CREATE EXTENSION IF NOT EXISTS pgcrypto");
        await client.query(
          `ALTER TABLE services ALTER COLUMN id SET DEFAULT gen_random_uuid()`,
        );
      }
    } else if (dataType === "integer") {
      if (isIdentity !== "YES" && !columnDefault) {
        await client.query(
          `ALTER TABLE services ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY`,
        );
      }
    }
  } finally {
    client.release();
  }
}

async function getServiceColumns() {
  const client = await pool.connect();
  try {
    const res = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = 'services'
    `);
    const cols = res.rows.map((r) => String(r.column_name));
    const nameCol = cols.includes("nome")
      ? "nome"
      : cols.includes("name")
        ? "name"
        : "name";
    const valueCol = cols.includes("valor")
      ? "valor"
      : cols.includes("value")
        ? "value"
        : "value";
    const descriptionCol = cols.includes("descricao")
      ? "descricao"
      : cols.includes("description")
        ? "description"
        : "description";
    return { nameCol, valueCol, descriptionCol };
  } finally {
    client.release();
  }
}

async function seedIfEmpty() {
  const client = await pool.connect();
  try {
    await ensureServicesTable();
    const countRes = await client.query(
      "SELECT COUNT(*)::int AS c FROM services",
    );
    const c = countRes.rows[0]?.c ?? 0;
    if (c > 0) {
      return;
    }
    const { nameCol, valueCol, descriptionCol } = await getServiceColumns();
    const items: Array<{ name: string; value: number; description: string }> = [
      {
        name: "Parcelamento dívida não ativa",
        value: 80.0,
        description: "Serviço de parcelamento para dívida não ativa",
      },
      {
        name: "Parcelamento dívida não ativa + 1 declaração",
        value: 120.0,
        description: "Inclui uma declaração",
      },
      {
        name: "Parcelamento dívida não ativa + até 2 declarações",
        value: 160.0,
        description: "Inclui até duas declarações",
      },
      {
        name: "Parcelamento dívida não ativa + mais de 2 declarações",
        value: 200.0,
        description: "Inclui mais de duas declarações",
      },
      {
        name: "Parcelamento dívida ativa, não ativa e envio ou não de uma declaração",
        value: 180.0,
        description: "Abrange dívidas ativa e não ativa",
      },
      {
        name: "Parcelamento dívida ativa e não ativa de MEIs excluídos",
        value: 200.0,
        description: "MEIs excluídos",
      },
      {
        name: "Parcelamento MEI excluído + 1 declaração",
        value: 200.0,
        description: "MEI excluído com uma declaração",
      },
      {
        name: "Parcelamento MEI excluído + 2+ declarações",
        value: 200.0,
        description: "MEI excluído com duas ou mais declarações",
      },
    ];
    for (const it of items) {
      await client.query(
        `INSERT INTO services (${nameCol}, ${valueCol}, ${descriptionCol}) VALUES ($1, $2, $3)`,
        [it.name, it.value, it.description],
      );
    }
  } finally {
    client.release();
  }
}

export async function GET() {
  try {
    await ensureServicesTable();
    const { nameCol, valueCol, descriptionCol } = await getServiceColumns();
    await seedIfEmpty();
    const res = await pool.query(
      `SELECT id, ${nameCol} AS name, ${valueCol} AS value, ${descriptionCol} AS description, created_at, updated_at FROM services ORDER BY created_at DESC`,
    );
    return NextResponse.json(res.rows);
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Erro ao listar serviços";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

export async function POST(req: Request) {
  try {
    await ensureServicesTable();
    const { nameCol, valueCol, descriptionCol } = await getServiceColumns();
    const body = await req.json();
    const name: string = body?.name;
    const valueNum: number = Number(body?.value);
    const description: string = body?.description ?? "";
    if (!name || Number.isNaN(valueNum)) {
      return NextResponse.json(
        { error: "name e value são obrigatórios" },
        { status: 400 },
      );
    }
    const res = await pool.query(
      `INSERT INTO services (${nameCol}, ${valueCol}, ${descriptionCol}) VALUES ($1, $2, $3) RETURNING id, ${nameCol} AS name, ${valueCol} AS value, ${descriptionCol} AS description, created_at, updated_at`,
      [name, valueNum, description],
    );
    return NextResponse.json(res.rows[0]);
  } catch (e) {
    const msg = e instanceof Error ? e.message : "Erro ao criar serviço";
    return NextResponse.json({ error: msg }, { status: 500 });
  }
}

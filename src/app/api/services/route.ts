import { NextResponse } from "next/server";
import pool from "@/lib/db";

export async function GET() {
  const client = await pool.connect();
  try {
    // Verificar se tabela existe
    const existsRes = await client.query(`
      SELECT EXISTS (
        SELECT 1 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'services'
      ) AS exists
    `);
    const exists = !!existsRes.rows[0]?.exists;

    if (!exists) {
      // Se não existe, retornar vazio (ou criar tabela se preferir, mas o POST cria)
      // Vamos criar tabela vazia para evitar erro no frontend
      await client.query(`
        CREATE TABLE services (
          id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name TEXT NOT NULL,
          value NUMERIC(10,2) NOT NULL,
          description TEXT,
          created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL
        )
      `);
      return NextResponse.json([]);
    }

    // Verificar colunas existentes para compatibilidade (name vs nome, etc)
    const colsRes = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = 'services'
    `);
    const cols = colsRes.rows.map((r) => String(r.column_name));

    // Mapear colunas
    const nameCol = cols.includes("nome")
      ? "nome"
      : cols.includes("name")
        ? "name"
        : "name";
    const valueCol = cols.includes("valor")
      ? "valor"
      : cols.includes("value")
        ? "value"
        : "value";
    const descriptionCol = cols.includes("descricao")
      ? "descricao"
      : cols.includes("description")
        ? "description"
        : "description";

    const query = `
      SELECT 
        id, 
        ${nameCol} as name, 
        ${valueCol} as value, 
        ${descriptionCol} as description, 
        created_at, 
        updated_at 
      FROM services 
      ORDER BY id ASC
    `;
    const res = await client.query(query);
    return NextResponse.json(res.rows);
  } catch (error) {
    console.error("Erro ao listar serviços:", error);
    return NextResponse.json(
      { error: "Erro ao listar serviços" },
      { status: 500 },
    );
  } finally {
    client.release();
  }
}

async function ensureServicesTable() {
  const client = await pool.connect();
  try {
    const existsRes = await client.query(`
      SELECT EXISTS (
        SELECT 1 
        FROM information_schema.tables 
        WHERE table_schema = 'public' AND table_name = 'services'
      ) AS exists
    `);
    const exists = !!existsRes.rows[0]?.exists;

    if (!exists) {
      await client.query(`
        CREATE TABLE services (
          id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
          name TEXT NOT NULL,
          value NUMERIC(10,2) NOT NULL,
          description TEXT,
          created_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL,
          updated_at TIMESTAMP WITHOUT TIME ZONE DEFAULT NOW() NOT NULL
        )
      `);
      return;
    }

    // Migration: Adicionar colunas faltantes se tabela já existe
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS name TEXT`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS value NUMERIC(10,2)`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS description TEXT`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS created_at TIMESTAMP WITHOUT TIME ZONE`,
    );
    await client.query(
      `ALTER TABLE services ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP WITHOUT TIME ZONE`,
    );

    // Set defaults
    await client.query(
      `ALTER TABLE services ALTER COLUMN created_at SET DEFAULT NOW()`,
    );
    await client.query(
      `ALTER TABLE services ALTER COLUMN updated_at SET DEFAULT NOW()`,
    );

    // Ensure ID is safe (identity or uuid)
    const idInfoRes = await client.query(`
      SELECT data_type, is_identity, column_default
      FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = 'services' AND column_name = 'id'
    `);
    const dataType: string | undefined = idInfoRes.rows[0]?.data_type;
    const isIdentity: string | undefined = idInfoRes.rows[0]?.is_identity;
    const columnDefault: string | null | undefined =
      idInfoRes.rows[0]?.column_default;

    if (dataType === "uuid") {
      if (!columnDefault) {
        await client.query("CREATE EXTENSION IF NOT EXISTS pgcrypto");
        await client.query(
          `ALTER TABLE services ALTER COLUMN id SET DEFAULT gen_random_uuid()`,
        );
      }
    } else if (dataType === "integer") {
      if (isIdentity !== "YES" && !columnDefault) {
        await client.query(
          `ALTER TABLE services ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY`,
        );
      }
    }
  } finally {
    client.release();
  }
}

async function getServiceColumns() {
  const client = await pool.connect();
  try {
    const res = await client.query(`
      SELECT column_name 
      FROM information_schema.columns 
      WHERE table_schema = 'public' AND table_name = 'services'
    `);
    const cols = res.rows.map((r) => String(r.column_name));

    // Preferencia para colunas legadas se existirem
    const nameCol = cols.includes("nome")
      ? "nome"
      : cols.includes("name")
        ? "name"
        : "name";
    const valueCol = cols.includes("valor")
      ? "valor"
      : cols.includes("value")
        ? "value"
        : "value";
    const descriptionCol = cols.includes("descricao")
      ? "descricao"
      : cols.includes("description")
        ? "description"
        : "description";

    return { nameCol, valueCol, descriptionCol };
  } finally {
    client.release();
  }
}

async function seedIfEmpty() {
  const client = await pool.connect();
  try {
    const res = await client.query("SELECT COUNT(*) FROM services");
    const count = parseInt(res.rows[0].count);
    if (count === 0) {
      const { nameCol, valueCol, descriptionCol } = await getServiceColumns();
      await client.query(
        `INSERT INTO services (${nameCol}, ${valueCol}, ${descriptionCol}) VALUES 
        ($1, $2, $3),
        ($4, $5, $6),
        ($7, $8, $9)`,
        [
          "Abertura de MEI",
          150.0,
          "Processo completo de abertura de Microempreendedor Individual",
          "Regularização de Pendências",
          200.0,
          "Análise e regularização de pendências fiscais",
          "Declaração Anual",
          100.0,
          "Envio da declaração anual de faturamento (DASN-SIMEI)",
        ],
      );
    }
  } catch (e) {
    console.error("Erro ao seedar serviços:", e);
  } finally {
    client.release();
  }
}

export async function POST(req: Request) {
  try {
    await ensureServicesTable();
    // await seedIfEmpty(); // Opcional: seedar apenas se quiser popular inicialmente

    const { nameCol, valueCol, descriptionCol } = await getServiceColumns();
    const body = await req.json();
    const { name, value, description } = body;

    if (!name || value === undefined) {
      return NextResponse.json(
        { error: "Nome e valor são obrigatórios" },
        { status: 400 },
      );
    }

    const res = await pool.query(
      `INSERT INTO services (${nameCol}, ${valueCol}, ${descriptionCol}) VALUES ($1, $2, $3) RETURNING id, ${nameCol} as name, ${valueCol} as value, ${descriptionCol} as description, created_at, updated_at`,
      [name, value, description || ""],
    );

    return NextResponse.json(res.rows[0]);
  } catch (error) {
    console.error("Erro ao criar serviço:", error);
    return NextResponse.json(
      { error: "Erro ao criar serviço" },
      { status: 500 },
    );
  }
}
